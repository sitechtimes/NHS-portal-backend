import json
import re
from pathlib import Path
from django.conf import settings


def sanitize_name(name: str) -> str:
    """Convert Postman request name to valid Python test method name."""
    name = re.sub(r"[^0-9a-zA-Z]+", "_", name.strip().lower())
    if not name.startswith("test_"):
        name = f"test_{name}"
    return name


def parse_url(raw_url: str) -> str:
    """Remove Postman variables like {{base_url}}."""
    return re.sub(r"\{\{.*?\}\}", "", raw_url)


def clean_raw_json(raw: str) -> str:
    """Remove Postman-style comment lines and inline comments."""
    if not raw:
        return raw
    lines = raw.splitlines()
    clean_lines = []
    for line in lines:
        stripped = line.strip()
        if stripped.startswith("//"):
            continue
        # Remove inline comments
        stripped = re.sub(r"//.*", "", stripped)
        clean_lines.append(stripped)
    return "\n".join(clean_lines).strip()


def extract_body(request_obj):
    """Extract body and convert JSON → Python dict safely."""
    req_body = request_obj.get("body")
    if not req_body:
        return None

    mode = req_body.get("mode")
    if mode == "raw":
        raw = clean_raw_json(req_body.get("raw", ""))
        if not raw:
            return None
        try:
            parsed = json.loads(raw)
            return parsed
        except Exception:
            return None
    elif mode == "formdata":
        return {
            item["key"]: item.get("value", "")
            for item in req_body.get("formdata", [])
            if item.get("type") == "text"
        }
    return None


def extract_headers(request_obj):
    """Extract headers (Authorization, etc.)."""
    headers = {}
    for header in request_obj.get("header", []):
        key, val = header.get("key"), header.get("value")
        if key and val:
            headers[key] = val
    return headers or None


def python_repr(data):
    """Return valid Python literal for JSON-compatible data."""
    return (
        json.dumps(data, indent=4)
        .replace("true", "True")
        .replace("false", "False")
        .replace("null", "None")
    )


def generate_test(item, response):
    """Generate a DRF test method string."""
    name = sanitize_name(item.get("name", "unnamed"))
    req = item["request"]
    method = req["method"].lower()
    url = parse_url(req["url"]["raw"])
    expected_code = response.get("code", 200)

    body = extract_body(req)
    headers = extract_headers(req)

    header_code = ""
    if headers:
        header_dict = {k: v for k, v in headers.items()}
        header_code = f"        self.client.credentials(**{{'HTTP_' + k.upper().replace('-', '_'): v for k, v in {header_dict}.items()}})\n"

    if body:
        body_str = python_repr(body)
        call = f'self.client.{method}("{url}", {body_str}, format="json")'
    else:
        call = f'self.client.{method}("{url}")'

    return f"""
    def {name}(self):
        \"\"\"Auto-generated test for {url}\"\"\"
{header_code}        response = {call}
        self.assertEqual(
            response.status_code, {expected_code},
            msg=f"Expected {expected_code} but got {{response.status_code}} for {url}"
        )
    """


def process_postman_collection(file_path):
    """Parse Postman collection and create test functions."""
    data = json.loads(Path(file_path).read_text())
    tests = []
    for folder in data.get("item", []):
        items = folder.get("item", [folder])
        for item in items:
            responses = item.get("response", [])
            if not responses:
                continue
            tests.append(generate_test(item, responses[0]))
    return tests


def write_test_file(tests, output_file="test_auto_generated.py"):
    """Write generated test methods into a single test file."""
    content = (
        "from rest_framework.test import APITestCase\n\n\n"
        "class AutoGeneratedPostmanTests(APITestCase):\n"
        "    base_url = 'http://localhost:8000'\n" + "".join(tests)
    )
    Path(output_file).write_text(content)
    print(f"✅ Generated {len(tests)} tests → {output_file}")


def run(*args):
    """
    Django Extensions entry point.
    Usage:
        python manage.py runscript generate_drf_tests_from_postman [input_json] [output_py]
    """
    input_file = "postman_collection.json"
    output_file = "tests.py"

    input_path = Path(settings.BASE_DIR) / "scripts" / "data" / input_file
    output_path = Path(settings.BASE_DIR) / "tests" / output_file

    if not input_path.exists():
        print(f"❌ File not found: {input_path}")
        return

    tests = process_postman_collection(input_path)
    write_test_file(tests, output_path)
